---
title: 'Rust Agent çš„é•¿æœŸè®°å¿†è®¾è®¡ï¼šåˆ«å†æŠŠä¸€åˆ‡éƒ½å¡è¿› Prompt äº†'
date: '2026-01-04'
description: 'æ·±å…¥è®²è§£å¦‚ä½•ç”¨ Rust æ„å»ºä¸€ä¸ªå…·å¤‡é•¿æœŸè¿è¡Œèƒ½åŠ›çš„ AI Agentï¼Œé‡ç‚¹å…³æ³¨è®°å¿†ç³»ç»Ÿçš„è®¾è®¡ä¸å®ç°ã€‚'
tags: ['Rust', 'AI Agent']
---

å¦‚æœä½ å·²ç»å†™è¿‡ Agentï¼Œä½ ä¸€å®šé‡åˆ°è¿‡è¿™ä¸ªé˜¶æ®µğŸ‘‡

> ä¸€å¼€å§‹å¾ˆèªæ˜
> è·‘å‡ è½®ä¹‹åå¼€å§‹èƒ¡è¨€ä¹±è¯­
> å†è·‘ä¸€ä¼šå„¿å°±å¿˜äº†è‡ªå·±æ˜¯è°

**æ ¹å› åªæœ‰ä¸€ä¸ªï¼šè®°å¿†è®¾è®¡æ˜¯é”™çš„ã€‚**

---

## ä¸€ä¸ªæ®‹é…·ç°å®ï¼šLLM æ²¡æœ‰â€œè®°å¿†â€ï¼Œåªæœ‰ä¸Šä¸‹æ–‡

LLM æ‰€è°“çš„â€œè®°å¿†â€ï¼Œæœ¬è´¨æ˜¯ï¼š

* ä½ è¿™æ¬¡ request é‡Œç»™äº†å¤šå°‘ token
* æ¨¡å‹**ä¸ä¼šè®°å¾—**ä¸Šä¸€æ¬¡è¯·æ±‚çš„ä»»ä½•ä¸œè¥¿

æ‰€ä»¥å¾ˆå¤š Agent çš„â€œè®°å¿†æ–¹æ¡ˆâ€æ˜¯ï¼š

> ğŸ‘‰ æŠŠæ‰€æœ‰å†å²å¯¹è¯ï¼Œå…¨å¡è¿› prompt

ç»“æœæ˜¯ï¼š

* âŒ token çˆ†ç‚¸
* âŒ æˆæœ¬å¤±æ§
* âŒ ä¿¡æ¯å™ªå£°è¶Šæ¥è¶Šå¤§
* âŒ æ¨¡å‹åè€ŒæŠ“ä¸åˆ°é‡ç‚¹

**çœŸæ­£å¯ç”¨çš„ Agentï¼Œè®°å¿†ä¸€å®šæ˜¯åˆ†å±‚çš„ã€‚**

---

## Agent çš„ä¸‰å±‚è®°å¿†æ¨¡å‹ï¼ˆéå¸¸é‡è¦ï¼‰

è¿™æ˜¯æˆ‘å¼ºçƒˆå»ºè®®ä½ åœ¨æ–‡ç« é‡Œå¼ºè°ƒçš„ä¸€å¼ â€œè®¤çŸ¥åœ°å›¾â€ï¼š

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Working Memory     â”‚  å½“å‰ä¸Šä¸‹æ–‡ï¼ˆçŸ­æœŸï¼‰
â”‚ (Short-Term)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Episodic Memory    â”‚  äº‹ä»¶ / è¡Œä¸ºè®°å½•
â”‚ (Long-Term Raw)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Semantic Memory    â”‚  å¯æ£€ç´¢çš„çŸ¥è¯†
â”‚ (Vector /  Index)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

æˆ‘ä»¬ä¸€å±‚ä¸€å±‚æ¥ï¼Œç”¨ **Rust çš„æ–¹å¼**å®ç°ã€‚

---

## Working Memoryï¼šä¸æ˜¯â€œè¶Šå¤šè¶Šå¥½â€ï¼Œè€Œæ˜¯â€œåˆšåˆšå¥½â€

### é—®é¢˜ï¼šä¸ºä»€ä¹ˆä¸Šä¸‹æ–‡è¶Šé•¿ï¼ŒAgent è¶Šè ¢ï¼Ÿ

å› ä¸º LLM å¹¶ä¸ä¼šå¸®ä½ åšâ€œä¿¡æ¯ä¼˜å…ˆçº§æ’åºâ€ã€‚

æ‰€ä»¥ Working Memory çš„åŸåˆ™æ˜¯ï¼š

> **åªä¿ç•™ï¼šå½“å‰å†³ç­–çœŸæ­£éœ€è¦çš„ä¿¡æ¯**

### Rust å®ç°ï¼šæ»‘åŠ¨çª—å£ + è§’è‰²è¿‡æ»¤

```rust
pub struct WorkingMemory {
    messages: Vec<ChatMessage>,
    max_tokens: usize,
}
```

ä½ å¯ä»¥åœ¨ push çš„æ—¶å€™åšä¸‰ä»¶äº‹ï¼š

1. ä¸¢å¼ƒå¤ªè€çš„ tool è¾“å‡º
2. ä¿ç•™ user goal + æœ€è¿‘ reasoning
3. å¿…è¦æ—¶ç”¨ LLM **å…ˆæ‘˜è¦å†ä¿ç•™**

```rust
pub fn compact(&mut self) {
    if self.messages.len() > 20 {
        let summary = summarize_with_llm(&self.messages[..10]);
        self.messages.drain(0..10);
        self.messages.insert(0, summary);
    }
}
```

ğŸ“Œ **è®°å¿†å‹ç¼©æ˜¯ Agent æˆç†Ÿçš„æ ‡å¿—**

---

## Episodic Memoryï¼šAgent çš„â€œé»‘åŒ£å­â€

è¿™æ˜¯å¾ˆå¤šæ•™ç¨‹å®Œå…¨ä¸è®²ã€ä½†ç”Ÿäº§ç¯å¢ƒå¿…ä¸å¯å°‘çš„éƒ¨åˆ†ã€‚

### ä»€ä¹ˆæ˜¯ Episodic Memoryï¼Ÿ

ğŸ‘‰ Agent æ¯ä¸€æ¬¡é‡è¦è¡Œä¸ºçš„**ä¸å¯å˜è®°å½•**

æ¯”å¦‚ï¼š

```json
{
  "ts": "2026-01-04T01:21:00Z",
  "step": 7,
  "action": "tool_call",
  "tool": "http_get",
  "input": {"url": "..."},
  "result": "timeout"
}
```

### Rust å®ç°ï¼šAppend-only JSONL

```rust
pub struct EpisodicMemory {
    writer: tokio::fs::File,
}

impl EpisodicMemory {
    pub async fn record(&mut self, event: &Value) -> Result<()> {
        use tokio::io::AsyncWriteExt;
        self.writer.write_all(event.to_string().as_bytes()).await?;
        self.writer.write_all(b"\n").await?;
        Ok(())
    }
}
```

ğŸ’¡ ä¸ºä»€ä¹ˆä¸ç”¨æ•°æ®åº“ï¼Ÿ

* append-onlyï¼š**å´©æºƒä¸ä¸¢æ•°æ®**
* äººç±»å¯è¯»
* åæœŸå¯ç¦»çº¿åˆ†æ / å›æ”¾ / å¾®è°ƒ

> **Agent æ²¡æœ‰ episodic memoryï¼Œå°±æ— æ³• Debugã€‚**

---

## çœŸæ­£æ‹‰å¼€å·®è·çš„ï¼šSemantic Memoryï¼ˆå‘é‡è®°å¿†ï¼‰

è¿™ä¸€æ­¥ï¼ŒAgent æ‰çœŸçš„â€œåƒåœ¨å­¦ä¹ â€ã€‚

### Semantic Memory çš„ä½œç”¨åªæœ‰ä¸€å¥è¯ï¼š

> **å½“é‡åˆ°ç›¸ä¼¼é—®é¢˜æ—¶ï¼Œèƒ½æƒ³èµ·â€œä»¥å‰å‘ç”Ÿè¿‡ä»€ä¹ˆâ€**

---

## Semantic Memory çš„æœ€å°å¯ç”¨è®¾è®¡

æˆ‘ä»¬ä¸ä¸€ä¸Šæ¥å°±ä¸Š Milvus / Pineconeã€‚

å…ˆåšä¸€ä¸ª **å¯æ§ã€å¯åµŒå…¥çš„æœ¬åœ°æ–¹æ¡ˆ**ã€‚

### æ•°æ®ç»“æ„

```rust
pub struct MemoryChunk {
    pub id: Uuid,
    pub embedding: Vec<f32>,
    pub text: String,
}
```

### å­˜å‚¨æ–¹æ¡ˆï¼ˆæç®€ä½†å¥½ç”¨ï¼‰

* SQLiteï¼ˆå…ƒæ•°æ®ï¼‰
* embeddings å­˜ BLOB
* ä½™å¼¦ç›¸ä¼¼åº¦åœ¨å†…å­˜ç®—

---

## Embedding æ˜¯â€œæ…¢æ“ä½œâ€ï¼Œä¸€å®šè¦å¼‚æ­¥åŒ–

è¿™æ˜¯ä¸€ä¸ªå¾ˆå¤šäººè¸©è¿‡çš„å‘ã€‚

```rust
pub async fn embed(text: &str) -> Result<Vec<f32>> {
    // è°ƒç”¨ embedding model
}
```

**åŸåˆ™ï¼š**

* âŒ ä¸è¦åœ¨ Agent ä¸»å¾ªç¯åŒæ­¥è°ƒç”¨
* âœ… åå°å¼‚æ­¥å†™å…¥ semantic memory

```rust
tokio::spawn(async move {
    let emb = embed(&text).await?;
    semantic_memory.insert(text, emb).await?;
});
```

---

## æ£€ç´¢ï¼šä¸æ˜¯â€œæœ€ç›¸ä¼¼â€ï¼Œè€Œæ˜¯â€œæœ€æœ‰ç”¨â€

å¤©çœŸçš„å†™æ³•ï¼š

```rust
top_k_by_cosine_similarity(query_embedding)
```

ä½†çœŸæ­£å¥½ç”¨çš„åšæ³•æ˜¯ï¼š

> **ç›¸ä¼¼åº¦ Ã— æ—¶é—´è¡°å‡ Ã— æˆåŠŸæƒé‡**

```text
score = similarity * freshness * success_rate
```

è¿™ä¸€æ­¥éå¸¸é€‚åˆä½ åœ¨å…¬ä¼—å·é‡Œå¼ºè°ƒï¼š

> Agent çš„â€œè®°å¿†è´¨é‡â€ï¼Œæ¯”è®°å¿†æ•°é‡é‡è¦ 100 å€ã€‚

---

## Semantic Memory å¦‚ä½•å‚ä¸ Agent æ¨ç†ï¼Ÿ

åœ¨ **æ¯ä¸€è½® LLM è°ƒç”¨ä¹‹å‰**ï¼š

```text
1. å–å½“å‰ goal
2. embedding
3. ä» semantic memory æ£€ç´¢ top-k
4. ä½œä¸ºâ€œå‚è€ƒèµ„æ–™â€æ‹¼è¿› system prompt
```

ç¤ºä¾‹ Prompt ç‰‡æ®µï¼š

```text
Relevant past experiences:
- Previously, HTTP timeout was solved by lowering concurrency.
- Similar error occurred when RPC rate limit exceeded.
```

ğŸ“Œ æ³¨æ„ï¼š
ä¸æ˜¯å½“ä½œâ€œå¯¹è¯å†å²â€ï¼Œè€Œæ˜¯**å‚è€ƒçŸ¥è¯†**

---

## è®°å¿†ç³»ç»Ÿçš„ 4 æ¡å·¥ç¨‹é“å¾‹ï¼ˆå¼ºçƒˆå»ºè®®åŸæ–‡ç…§æŠ„ï¼‰

ä½ å¯ä»¥åœ¨æ–‡ç« ç»“å°¾ç”¨â€œæ€»ç»“é‡‘å¥â€ï¼š

1. **Working Memory è¶ŠçŸ­ï¼ŒAgent è¶Šèªæ˜**
2. **Episodic Memory æ˜¯ä¸ºäº† Debugï¼Œä¸æ˜¯ä¸ºäº†æ¨ç†**
3. **Semantic Memory åªå­˜â€œå€¼å¾—è¢«æƒ³èµ·çš„äº‹â€**
4. **è®°å¿†ä¸æ˜¯æ•°æ®ç»“æ„ï¼Œæ˜¯ç­–ç•¥**

---

## åˆ°è¿™é‡Œï¼Œä½ çš„ Agent å·²ç»ä¸å†æ˜¯ Demo

å¦‚æœä½ å·²ç»è·Ÿåˆ°ç¬¬ä¸‰ç¯‡ï¼Œä½ çš„ Agent ç°åœ¨å·²ç»å…·å¤‡ï¼š

* âœ… å¹¶å‘æ‰§è¡Œå™¨
* âœ… æˆæœ¬å¯æ§
* âœ… å¯ Debug
* âœ… å¯å­¦ä¹ 
* âœ… å¯é•¿æœŸè¿è¡Œ

> è¿™å·²ç»**è¿œè¿œè¶…è¿‡ 90% å¼€æº Agent æ¡†æ¶çš„å·¥ç¨‹æ·±åº¦**ã€‚
